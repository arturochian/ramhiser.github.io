<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: R | John Ramey]]></title>
  <link href="http://ramhiser.com/blog/categories/r/atom.xml" rel="self"/>
  <link href="http://ramhiser.com/"/>
  <updated>2012-08-12T20:47:01-07:00</updated>
  <id>http://ramhiser.com/</id>
  <author>
    <name><![CDATA[John Ramey]]></name>
    <email><![CDATA[johnramey@gmail.com]]></email>
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[Pseudo-Random vs. Random Numbers in R]]></title>
    <link href="http://ramhiser.com/blog/2011/11/25/pseudo-random-vs-random-numbers-in-r/"/>
    <updated>2011-11-25T03:08:00-08:00</updated>
    <id>http://ramhiser.com/blog/2011/11/25/pseudo-random-vs-random-numbers-in-r</id>
    <content type="html"><![CDATA[<p>Earlier, I found <a href="http://www.boallen.com/random-numbers.html">an interesting post from Bo Allen</a> on <a href="http://en.wikipedia.org/wiki/Pseudorandom_number_generator">pseudo-random</a> vs <a href="http://en.wikipedia.org/wiki/Random_number">random numbers</a>, where the author uses a simple bitmap (<a href="http://en.wikipedia.org/wiki/Heat_map">heat map</a>) to show that the <strong>rand</strong> function in <a href="http://www.php.net/">PHP</a> has a systematic pattern and compares these to <strong>truly random</strong> numbers obtained from <a href="http://www.random.org/">random.org</a>. The post's results suggest that pseudo-randomness in <a href="http://www.php.net/">PHP</a> is faulty and, in general, should not be underestimated in practice. Of course, the findings should not be too surprising, as there is a large body of literature on the subtleties, philosophies, and implications of the <strong>pseudo</strong> aspect of the most common approaches to random number generation. However, it is silly that <a href="http://www.php.net/">PHP</a>'s <a href="http://en.wikipedia.org/wiki/Random_number_generation">random number generator (RNG)</a> displays such an obvious pattern nowadays because there are several decent, well-studied pseudo-RNG algorithms available as well as numerous tests for randomness.  For a good introduction to <a href="http://en.wikipedia.org/wiki/Random_number_generation">RNG</a>, I recommend <a href="http://www.johndcook.com/blog/2010/12/06/how-to-test-a-random-number-generator-2/">John D. Cook's discussion on testing a random number generator</a>.</p>

<p>Now, I would never use <a href="http://www.php.net/">PHP</a> for any (serious) statistical analysis, partly due to my fondness for <a href="http://www.r-project.org/">R</a>, nor do I doubt the practicality of the <a href="http://en.wikipedia.org/wiki/Random_number_generation">RNG</a> in <a href="http://www.r-project.org/">R</a>. But I was curious to see what would happen. So, created equivalent plots in <a href="http://www.r-project.org/">R</a> to see if a <strong>rand</strong> equivalent would exhibit a systematic pattern like in <a href="http://www.php.net/">PHP</a>, even if less severe. Also, for comparison, I chose to use <a href="http://cran.r-project.org/web/packages/random/index.html">the <strong>random</strong> package</a>, from <a href="http://dirk.eddelbuettel.com/">Dirk Eddelbuettel</a>, to draw <strong>truly random</strong> numbers from <a href="http://www.random.org/">random.org</a>. Until today, I had only heard of <a href="http://cran.r-project.org/web/packages/random/index.html">the <strong>random</strong> package</a> but had never used it.</p>

<p>I have provided the function <strong>rand_bit_matrix</strong>, which requires the number of rows and columns to display in the plotted bitmap. To create the bitmaps, I used <a href="http://cran.r-project.org/web/packages/pixmap/index.html">the <strong>pixmap</strong> package</a> rather than <a href="http://had.co.nz/ggplot2/">the much-loved <strong>ggplot2</strong> package</a>, simply because of how easy it was for me to create the plots. (If you are concerned that I have lost the faith, please note that I am aware of the awesomeness of <a href="http://had.co.nz/ggplot2/"><strong>ggplot2</strong></a> and <a href="http://ramhiser.com/blog/2011/06/05/conways-game-of-life-in-r-with-ggplot2-and-animation/">its ability</a> <a href="http://learnr.wordpress.com/2010/01/26/ggplot2-quick-heatmap-plotting/">to create heat maps</a>.)</p>

<p>It is important to note that there were two challenges that I encountered when using drawing <strong>truly random numbers</strong>.</p>

<ol>
<li>Only 10,000 numbers can be drawn at once from <a href="http://www.random.org/">random.org</a>. (This is denoted as <strong>max_n_random.org</strong> in the function below.)</li>
<li>There is a daily limit to the number of times the <a href="http://www.random.org/">random.org</a> service will provide numbers.</li>
</ol>


<p>To overcome the first challenge, I split the total number of bits into separate calls, if necessary. This approach, however, increases our number of requests, and after too many requests, you will see the error: <strong>random.org suggests to wait until tomorrow</strong>. Currently, I do not know the exact number of allowed requests or if the amount of requested random numbers is a factor, but looking back, I would guess about 20ish large requests is too much.</p>

<p>Below, I have plotted 500 x 500 bitmaps based on the <em>random</em> bits from both of <a href="http://www.r-project.org/">R</a> and <a href="http://www.random.org/">random.org</a>. As far as I can tell, no apparent patterns are visible in either plot, but from the graphics alone, our conclusions are limited to ruling out obvious systematic patterns, which were exhibited from the <a href="http://www.php.net/">PHP</a> code. I am unsure if the <a href="http://www.php.net/">PHP</a> folks formally tested their <a href="http://en.wikipedia.org/wiki/Random_number_generation">RNG</a> algorithms for <strong>randomness</strong>, but even if they did, the code in both <a href="http://www.r-project.org/">R</a> and <a href="http://www.php.net/">PHP</a> is straightforward and provides a quick eyeball test. Armed with similar plots alone, the <a href="http://www.php.net/">PHP</a> devs could have sought for better <a href="http://en.wikipedia.org/wiki/Random_number_generation">RNG</a> algorithms — perhaps, borrowed those from <a href="http://www.r-project.org/">R</a>.</p>

<p>``` r
library("plyr")
library("pixmap")
library("random")</p>

<p>rand_bit_matrix &lt;- function(num_rows = 500, num_cols = 500, max_n_random.org = 10000,</p>

<pre><code>seed = NULL) {
# I have copied the following function directly from help('integer').
is.wholenumber &lt;- function(x, tol = .Machine$double.eps^0.5) {
    abs(x - round(x)) &lt; tol
}

# The number of bits to draw at 'random'.
n &lt;- num_rows * num_cols
if (n &lt;= 0 || !is.wholenumber(n)) {
    stop("The number of bits 'n' should be a natural number.")
}

if (!is.null(seed)) {
    set.seed(seed)
}

# Create a matrix of pseudo-random bits.
bits_R &lt;- replicate(n = num_cols, sample(c(0, 1), size = num_rows, replace = TRUE))

# Because random.org will only return a maximum of 10,000 numbers at a
# time, we break this up into several calls.
seq_n_random.org &lt;- rep.int(x = max_n_random.org, times = n%/%max_n_random.org)
if (n%%max_n_random.org &gt; 0) {
    seq_n_random.org &lt;- c(seq_n_random.org, n%%max_n_random.org)
}
bits_random.org &lt;- lapply(seq_n_random.org, function(n) {
    try_default(randomNumbers(n = n, min = 0, max = 1, col = 1), NA)
})

bits_random.org &lt;- matrix(unlist(bits_random.org), nrow = num_rows, ncol = num_cols)

list(R = bits_R, random.org = bits_random.org)
</code></pre>

<p>}</p>

<p>bit_mats &lt;- rand_bit_matrix(num_rows = 500, num_cols = 500, seed = 42)</p>

<p>with(bit_mats, plot(pixmapGrey(data = R, nrow = nrow(R), ncol = ncol(R)), main = "R"))
```</p>

<p><img src="http://i.imgur.com/hZd2N.png" alt="plot of chunk code" /></p>

<p>``` r
with(bit_mats, plot(pixmapGrey(data = random.org, nrow = nrow(random.org),</p>

<pre><code>ncol = ncol(random.org)), main = "random.org"))
</code></pre>

<p>```</p>

<p><img src="http://i.imgur.com/E59lB.png" alt="plot of chunk code" /></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Conway's Game of Life in R with ggplot2 and animation]]></title>
    <link href="http://ramhiser.com/blog/2011/06/05/conways-game-of-life-in-r-with-ggplot2-and-animation/"/>
    <updated>2011-06-05T19:04:00-07:00</updated>
    <id>http://ramhiser.com/blog/2011/06/05/conways-game-of-life-in-r-with-ggplot2-and-animation</id>
    <content type="html"><![CDATA[<p>In undergrad I had a computer science professor that piqued my interest in applied mathematics, beginning with <a href="http://en.wikipedia.org/wiki/Conway%27s_Game_of_Life">Conway's Game of Life</a>. At first, the Game of Life (not the board game) appears to be quite simple — perhaps, too simple — but it has been widely explored and is useful for modeling systems over time. It has been forever since I wrote my first version of this in C++, and I happily report that there will be no nonsense here.</p>

<p>The basic idea is to start with a grid of cells, where each cell is either a zero (dead) or a one (alive). We are interested in watching the population behavior over time to see if the population dies off, has some sort of equilibrium, etc. <a href="http://en.wikipedia.org/wiki/John_Horton_Conway">John Conway</a> studied many possible ways to examine population behaviors and ultimately decided on the following rules, which we apply to each cell for the current tick (or generation).</p>

<ol>
<li>Any live cell with fewer than two live neighbours dies, as if caused by under-population.</li>
<li>Any live cell with two or three live neighbours lives on to the next generation.</li>
<li>Any live cell with more than three live neighbours dies, as if by overcrowding.</li>
<li>Any dead cell with exactly three live neighbours becomes a live cell, as if by reproduction</li>
</ol>


<p>Although there are <a href="http://www.statisticsblog.com/2010/05/game-of-life-in-r/">other versions</a> of this in R, I decided to give it a shot myself. I am not going to provide a walkthrough of the code as I may normally do, but the code should be simple enough to understand for one proficient in R. It may have been unnecessary to implement this with the foreach package, but I wanted to get some more familiarity with foreach, so I did.</p>

<p>The set of grids is stored as a list, where each element is a matrix of zeros and ones. Each matrix is then converted to an image with ggplot2, and the sequence of images is exported as a MP4 video with the <a href="http://cran.r-project.org/web/packages/animation/index.html">animation package</a>.</p>

<p>Let me know if you improve on my code any. I'm always interested in learning how to do things better.</p>

<p>``` r
library('foreach')
library('ggplot2')
library('animation')
library('reshape2')</p>

<h1>Determines how many neighboring cells around the (j,k)th cell have living organisms.</h1>

<h1>The conditionals are used to check if we are at a boundary of the grid.</h1>

<p>how_many_neighbors <- function(grid, j, k) {
  size <- nrow(grid)
  count <- 0
  if(j > 1) {</p>

<pre><code>count &lt;- count + grid[j-1, k]
if (k &gt; 1) count &lt;- count + grid[j-1, k-1]
if (k &lt; size) count &lt;- count + grid[j-1, k+1]
</code></pre>

<p>  }
  if(j &lt; size) {</p>

<pre><code>count &lt;- count + grid[j+1,k]
if (k &gt; 1) count &lt;- count + grid[j+1, k-1]
if (k &lt; size) count &lt;- count + grid[j+1, k+1]
</code></pre>

<p>  }
  if(k > 1) count &lt;- count + grid[j, k-1]
  if(k &lt; size) count &lt;- count + grid[j, k+1]
  count
}</p>

<h1>Creates a list of matrices, each of which is an iteration of the Game of Life.</h1>

<h1>Arguments</h1>

<h1>size: the edge length of the square</h1>

<h1>prob: a vector (of length 2) that generates cells with probability of death and life, respectively</h1>

<h1>returns a list of grids (matrices)</h1>

<p>game_of_life &lt;- function(size = 10, num_reps = 50, prob = c(0.5, 0.5)) {
  grid &lt;- list()
  grid[[1]] &lt;- replicate(size, sample(c(0,1), size, replace = TRUE, prob = prob))
  dev_null &lt;- foreach(i = seq_len(num_reps) + 1) %do% {</p>

<pre><code>grid[[i]] &lt;- grid[[i-1]]
foreach(j = seq_len(size)) %:%
  foreach(k = seq_len(size)) %do% {

    # Apply game rules.
    num_neighbors &lt;- how_many_neighbors(grid[[i]], j, k)
    alive &lt;- grid[[i]][j,k] == 1
    if(alive &amp;&amp; num_neighbors &lt;= 1) grid[[i]][j,k] &lt;- 0
    if(alive &amp;&amp; num_neighbors &gt;= 4) grid[[i]][j,k] &lt;- 0
    if(!alive &amp;&amp; num_neighbors == 3) grid[[i]][j,k] &lt;- 1
  }
</code></pre>

<p>  }
  grid
}</p>

<h1>Converts the current grid (matrix) to a ggplot2 image</h1>

<p>grid_to_ggplot &lt;- function(grid) {
  # Permutes the matrix so that melt labels this correctly.
  grid &lt;- grid[seq.int(nrow(grid), 1), ]
  grid &lt;- melt(grid)
  grid$value &lt;- factor(ifelse(grid$value, "Alive", "Dead"))
  p &lt;- ggplot(grid, aes(x=Var1, y=Var2, z = value, color = value))
  p &lt;- p + geom_tile(aes(fill = value))
  p  + scale_fill_manual(values = c("Dead" = "white", "Alive" = "black"))
}
```</p>

<p>As an example, I have created a 50-by-50 grid with a 10% chance that its initial values will be alive. The simulation has 500 iterations. You may add more, but this takes long enough already. Note
that the default frame rate, which is controlled by <strong>interval</strong>, is 1 second. I set it to 0.05
based to give a decent video.</p>

<p><code>r
set.seed(42)
game_grids &lt;- game_of_life(size = 50, num_reps = 500, prob = c(0.1, 0.9))
grid_ggplot &lt;- lapply(game_grids, grid_to_ggplot)
saveVideo(lapply(grid_ggplot, print), video.name = "animation.mp4", clean = TRUE, interval = 0.05)
</code></p>

<p>I uploaded the resulting video to YouTube for your viewing pleasure.</p>

<p><div class="embed-video-container"><iframe src="http://www.youtube.com/embed/TkH9qwHLwxk"></iframe></div></p>
]]></content>
  </entry>
  
</feed>
